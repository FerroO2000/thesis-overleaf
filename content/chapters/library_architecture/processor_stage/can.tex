\subsection{CAN}

Il \textit{CAN stage} rappresenta un \textit{Processor stage} specializzato per la decodifica di messaggi \textit{CAN} (\textit{Controller Area Network}) da un formato grezzo a una rappresentazione strutturata di segnali decodificati. A differenza dello \textit{Cannelloni stage}, che gestisce il livello di trasporto e incapsulamento su reti IP, il \textit{CAN stage} opera al livello semantico, estraendo i singoli segnali contenuti nei messaggi \textit{CAN} secondo una definizione di schema.

Un messaggio \textit{CAN} grezzo è semplicemente un identificatore (\textit{CAN ID}) associato a una serie di byte (payload). Tuttavia, i byte non sono auto-descrittivi: la loro interpretazione dipende completamente dallo schema di decodifica definito dai progettisti del sistema. Ad esempio, un payload di 8 byte potrebbe contenere pressione, temperatura, stato di allarme e altre grandezze fisiche, ognuna occupando un intervallo di bit specifico all'interno del buffer. Questi campi contenuti nel payload prendono il nome di \textit{segnali}. Lo \textit{CAN stage} traduce questa rappresentazione binaria in segnali nominati con valori tipizzati (booleani, interi, numeri in virgola mobile, enumerazioni), rendendo i dati direttamente intelligibili alle applicazioni a valle della \textit{pipeline}.

La libreria \textbf{Goccia} integra la libreria \textit{acmelib}~\cite{acmelib:github}, un \textit{framework} Go per la definizione e manipolazione di schemi \textit{CAN}. La configurazione dello \textit{CAN stage} accetta un elenco di oggetti \texttt{acmelib.Message}, ognuno dei quali rappresenta il modello di un messaggio \textit{CAN} specifico (identificato da un \textit{CAN ID}) e contiene la definizione del layout dei segnali.

All'inizializzazione dello \textit{stage}, viene costruita una mappa che associa a ogni \textit{CAN ID} la funzione di decodifica corrispondente. Durante l'elaborazione, quando arriva un messaggio grezzo, il \textit{decoder} recupera la funzione dalla mappa e l'invoca sul payload, ottenendo una lista di segnali decodificati con nome, valore grezzo e valore tipizzato.

Il messaggio ritornato dallo \textit{stage} incorpora la lista dei segnali decodificati. Per ogni segnale viene utilizzato un approccio \textit{tagging} tramite il campo \texttt{Type} per indicarne il tipo (booleano, intero, numero in virgola mobile, enumerazione), e il valore effettivo è memorizzato nel corrispondente campo tipizzato (\texttt{ValueFlag}, \texttt{ValueInt}, \texttt{ValueFloat}, \texttt{ValueEnum}). Questo approccio consente una gestione \textit{type-safe} senza ricorrere a interfacce generiche o \textit{reflection}, a scapito di un maggiore utilizzo di memoria.