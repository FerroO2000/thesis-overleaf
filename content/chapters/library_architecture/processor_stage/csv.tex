\subsection{CSV}

Lo \textit{CSV stage} rappresenta un \textit{Processor stage} specializzato per la serializzazione e deserializzazione di dati in formato \textit{CSV} (\textit{Comma-Separated Values}). Come lo \textit{Cannelloni stage}, la libreria \textbf{Goccia} fornisce due varianti: il \textit{CSV Decoder stage}, che trasforma dati \textit{CSV} grezzi in messaggi strutturati, e il \textit{CSV Encoder stage}, che compie l'operazione inversa. Questo consente l'integrazione di sorgenti dati \textit{CSV} (file, stream di rete) all'interno della \textit{pipeline} e l'esportazione di risultati elaborati in formato \textit{CSV}.

La configurazione dello \textit{CSV stage} è basata su uno schema dichiarativo composto dalle definizioni delle colonne. Per ogni colonna viene specificato il nome, il tipo di dato (stringa, intero, numero in virgola mobile, booleano, \textit{timestamp}) e, per \textit{timestamp}, il layout di \textit{parsing} (ad esempio RFC3339, ISO 8601, o layout personalizzato). Questo approccio consente di gestire file \textit{CSV} con tipi di dati eterogenei senza perdere informazioni di tipo durante la deserializzazione.

Il \textit{CSV Decoder stage} riceve dati \textit{CSV} grezzi (tipicamente da uno \textit{File stage} o \textit{UDP stage}) e li decodifica in messaggi strutturati. L'algoritmo di decodifica scansiona sequenzialmente il buffer di dati grezzi, carattere per carattere, accumulando i dati di una colonna in un buffer di stringhe. Quando incontra un byte che fa parte di un carattere multi-byte UTF-8 (bit più significativo impostato), utilizza \texttt{utf8.DecodeRune}~\cite{go:utf8:decoderune} per estrarre correttamente il carattere \textit{Unicode}, garantendo la compatibilità con dataset internazionali. I delimitatori di colonna (virgola) e di riga (\textit{newline}) segnalano il completamento di un valore e l'inizio di un nuovo. Il decoder gestisce correttamente righe incomplete, \textit{newline} assenti all'ultimo valore, e \textit{carriage return} (\texttt{\textbackslash r}) (comune nei file \textit{CSV} esportati da sistemi Windows). Per ogni colonna completata, il decoder estrae il tipo dalla definizione dello schema e invoca il metodo di decodifica specializzato sfruttando il pacchetto \texttt{strconv} della libreria standard~\cite{go:strconv}. Se la conversione del tipo fallisce (ad esempio, una stringa non convertibile a intero), nel messaggio generato dallo \textit{stage} viene impostato a \texttt{false} un flag che segnala l'insuccesso della decodifica. Questo approccio di \textit{soft-validation} è utile in scenari dove dati sporchi sono comuni.

Il \textit{CSV Encoder stage} compie l'operazione inversa: riceve messaggi \texttt{CSVMessage} (liste di righe) e li serializza in buffer \textit{CSV} grezzi. L'encoder, per ogni riga e colonna, scrive il valore tipizzato nello stream testuale, utilizzando le funzioni \texttt{strconv} per convertire interi e float a stringhe. Nel caso in cui una colonna non dovesse contenere un dato valido, l'encoder provvede a scrivere un valore di \textit{default}, garantendo che il chunk di file \textit{CSV} risultante sia sempre ben formattato, anche con dati incompleti. L'encoder utilizza un \texttt{strings.Builder} con capacità pre-allocata per ridurre le allocazioni dinamiche, massimizzando l'efficienza della serializzazione.

Un aspetto notevole è l'uso di \textit{object pooling} per i messaggi \texttt{CSVMessage}, in maniera analoga ai messaggi risultanti dallo \textit{UDP Ingress stage}. Viene utilizzato un \texttt{sync.Pool} per riciclare le istanze dei messaggi, riducendo la pressione sul \textit{garbage collector}. Quando un messaggio è distrutto, viene ripulito e restituito al pool per essere riutilizzato nella prossima decodifica. Questo è particolarmente importante in scenari con alto \textit{throughput} dove decine di migliaia di messaggi \textit{CSV} vengono processati al secondo. Similarmente agli altri \textit{Processor stage}, il \textit{CSV Decoder stage} è generico rispetto al tipo di input, consentendo di accettare dati \textit{CSV} da qualunque \textit{stage} che ritorni un messaggio implementante l'interfaccia di serializzazione. Il flusso tipico potrebbe essere: \textit{File stage} $\to$ \textit{CSV Decoder stage} $\to$ elaborazione specifica del dominio, oppure il percorso inverso per l'esportazione.
