\subsection{Cannelloni}

Lo \textit{Cannelloni stage} rappresenta un \textit{Processor stage} specializzato per la serializzazione e deserializzazione di messaggi nel formato \textit{Cannelloni}\cite{cannelloni:github}, uno standard di incapsulamento per messaggi \textit{CAN} (\textit{Controller Area Network}) progettato per il trasporto su reti IP. La libreria \textbf{goccia} fornisce due varianti dello \textit{stage}: il \textit{Cannelloni Decoder stage}, che trasforma dati \textit{Cannelloni} grezzi in messaggi \textit{CAN} strutturati, e il \textit{Cannelloni Encoder stage}, che compie l'operazione inversa. Sebbene logicamente rappresentino un unico tipo di elaborazione (bidirezionale), sono implementati come due \textit{stage} separati per conformarsi al modello unidirezionale di trasformazione della \textit{pipeline}.

Il protocollo \textit{CAN} è ampiamente utilizzato in ambito automotive e nei sistemi embedded per la comunicazione \textit{real-time} a bassa latenza. Tuttavia, il \textit{CAN} tradizionale è limitato a reti locali (bus seriale). Il formato \textit{Cannelloni} risolve questo vincolo consentendo l'incapsulamento di molteplici messaggi \textit{CAN} in un singolo pacchetto \textit{UDP}, abilitando il trasporto su reti IP. Questo approccio è particolarmente rilevante in scenari dove i dati \textit{CAN} provengono da \textit{gateway} remoti e devono essere elaborati centralmente.

<disegno frame cannelloni>

Il formato \textit{Cannelloni} è organizzato gerarchicamente. L'header del frame è composto da 5 byte: il campo \texttt{version} (1 byte) specifica la versione del protocollo; \texttt{opCode} (1 byte) contiene il codice operativo; \texttt{sequenceNumber} (1 byte) è il numero sequenziale del frame, utilizzato per il riordino e la rilevazione di perdite; \texttt{messageCount} (2 byte, \textit{big-endian}) indica il numero di messaggi \textit{CAN} contenuti nel frame. Segue quindi la sequenza dei messaggi \textit{CAN}, ciascuno con lunghezza variabile (minimo 5 byte): \texttt{canID} (4 byte, \textit{big-endian}) è l'identificatore del messaggio; \texttt{dataLen} (1 byte) specifica la lunghezza dei dati (0-8 per \textit{CAN} 2.0, 0-64 per \textit{CAN} FD), con il bit più significativo (0x80) che indica se il messaggio è \textit{CAN} FD; \texttt{canFDFlags} (1 byte, opzionale) contiene flag specifici di \textit{CAN} FD, presenti solamente se il bit di \textit{CAN} FD è impostato; \texttt{data} (variabile) è il payload del messaggio.

Il \textit{Cannelloni Decoder stage} riceve dati \textit{Cannelloni} grezzi (tipicamente da uno \textit{UDP stage}) e li decodifica in messaggi \textit{CAN} strutturati, eseguendo il parsing sequenziale del buffer contenente i dati grezzi. Questo buffer è ottenuto richiamando il metodo \texttt{GetBytes} definito dall'interfaccia di serializzazione utilizzata dagli \textit{Ingress stage} quali \textit{UDP}, \textit{TCP}, \textit{File} e \textit{Kafka}. Il \textit{decoder} verifica innanzitutto che il buffer contenga almeno 5 byte per l'header, quindi estrae i campi utilizzando accesso diretto ai byte e \texttt{binary.BigEndian} per i campi multi-byte. Per ogni messaggio \textit{CAN} nel frame, procede sequenzialmente estraendo l'identificatore, la lunghezza dei dati, e verificando se il messaggio è di tipo \textit{CAN} FD, per concludere copiando il payload nel messaggio deserializzato.

Il \textit{Cannelloni Encoder stage} compie l'operazione inversa: riceve messaggi di tipo \texttt{CannelloniMessage} (tipicamente generati da uno \textit{stage} precedente o costruiti manualmente) e li serializza in \textit{buffer} di byte. Questo \textit{buffer} viene successivamente inserito nel campo apposito del tipo \texttt{CannelloniEncodedMessage}.

Il messaggio \texttt{CannelloniMessage} implementa l'interfaccia \texttt{message.ReOrderable}, la quale espone il metodo \texttt{GetSequenceNumber}. Questo consente allo \textit{stage} \textit{ROB} (\textit{ReOrder Buffer}) posizionato a valle del decoder di riordinare i frame in arrivo in caso di perdita di pacchetti o arrivo fuori ordine dalla rete. Il numero sequenziale è mantenuto durante la codifica, garantendo che il riordino sia semanticamente corretto.

Sia il decoder che l'encoder generano uno span \textit{OpenTelemetry} per ogni frame elaborato, registrando il numero di messaggi \textit{CAN} contenuti nel frame tramite l'attributo \texttt{message\_count}. Questo fornisce visibilità granulare sui volumi di dati elaborati e sulla struttura interna dei frame, facilitando il monitoraggio della salute della \textit{pipeline} e la diagnostica di anomalie.
