\subsection{Tee}

Lo \textit{Tee stage} è un \textit{Processor stage} \textit{utility} specializzato nel duplicare i messaggi verso molteplici output \textit{connector}, consentendo il \textit{branching} della \textit{pipeline}. Il suo nome richiama l'omonimo comando \textit{Unix} \texttt{tee}, che copia lo standard input sia verso lo standard output che verso un file. Analogamente, questo \textit{stage} prende un messaggio in ingresso e lo distribuisce parallelamente verso $N$ output \textit{connector}, permettendo a molteplici sottopipeline di elaborare indipendentemente lo stesso dato.

Un aspetto cruciale del \textit{Tee stage} è che non esegue una copia profonda dei dati. Al contrario, la libreria \textbf{goccia} implementa un sistema di \textit{reference counting} sui messaggi: quando il metodo \texttt{Clone} del messaggio è invocato, viene creato un nuovo envelope che riferisce lo stesso payload sottostante, incrementando un contatore di riferimenti. Solo quando il contatore scende a zero (ossia quando tutti i cloni sono distrutti), il payload effettivo è deallocato. Questo design consente al \textit{Tee stage} di distribuire messaggi a costo praticamente costante, indipendentemente da quanto grandi siano i dati sottostanti. Di fatto vengono copiati solamente i metadati del messaggio, operazione resa possibile dal fatto che gli \textit{stage} a valle utilizzano il messaggio in input come un'istanza \textit{read-only}.

% <codice Clone>

Il \textit{Tee stage} legge un messaggio dal \textit{connector} di input e lo clona per ogni output \textit{connector} configurato. Non vi è alcuna elaborazione o filtraggio: ogni clone è identico all'originale in termini di payload e metadati. Se uno degli output \textit{connector} non riesce a ricevere il clone (ad esempio, è pieno o chiuso), solo quel ramo è interessato; gli altri continuano a ricevere i loro cloni. L'errore è loggato ma non interrompe la distribuzione verso gli altri output.

A differenza dei \textit{Processor stage} visti in precedenza, il \textit{Tee stage} non può utilizzare un \textit{worker pool}. È invece implementato come \textit{stage} \textit{standalone} che gestisce direttamente il ciclo di lettura e distribuzione. La configurazione è minimale: l'utente specifica semplicemente il \textit{connector} di input e un elenco di output \textit{connector} tramite un parametro \textit{variadic}. Al momento dell'inizializzazione, lo \textit{stage} valida che almeno un output \textit{connector} sia stato fornito.

Il \textit{Tee stage} è indispensabile in scenari dove i dati devono essere elaborati in parallelo da molteplici sottosistemi: ad esempio, un singolo flusso di messaggi \textit{CAN} potrebbe essere distribuito simultaneamente a uno \textit{stage} di storage, a uno di analisi \textit{real-time} e a uno di \textit{machine learning inference}. Il \textit{Tee stage} garantisce che ogni sottopipeline riceva una copia coerente del messaggio originale, senza contaminazione tra rami e senza duplicazione effettiva dei dati.
