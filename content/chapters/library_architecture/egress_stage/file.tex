\subsection{File Egress Stage}

Lo \textit{File Egress stage} rappresenta uno stage di esportazione progettato per persistere messaggi elaborati dalla pipeline in un file su disco, funzionando come punto di uscita persistente per flussi di dati che richiedono archiviazione locale o condivisione tramite \textit{filesystem}. Esso fornisce un meccanismo semplice e deterministico per scrivere sequenzialmente messaggi su \textit{filesystem} locale (append only), ideale per logging, tracing, analisi offline, e backup di dati elaborati.

La libreria \textbf{Goccia} fornisce una configurazione minimalista per il \textit{File Egress stage}, che mira a controllare i comportamenti di buffering e flushing dei dati verso il disco. Il parametro principale è \texttt{Path}, ovvero il percorso del file di destinazione, e la dimensione del buffer in cui accumulare i byte prima della scrittura su disco (default 4096 byte). Inoltre, vi sono altri due parametri per regolare il flushing, utili per forzare una scrittura del file a determinate condizioni. Quest'ultime riguardano la percentuale di riempimento del buffer e una deadline temporale (default: 1 secondo). La configurazione del buffering consente di controllare il trade-off tra latenza e throughput: buffer di piccole dimensioni e threshold basse producono flush frequenti, incrementando il numero di operazioni I/O su disco; buffer più grandi e threshold elevate riducono il numero di operazioni I/O ma introducono latenza maggiore nella persistenza.

Lo stage adotta un'architettura \textit{Single Worker Mode}, in contrasto con altri stage che supportano \textit{worker pool}. Questa scelta è dovuta alla natura sequenziale e seriale della scrittura su file: accedere contemporaneamente allo stesso file descriptor tramite molteplici goroutine richiederebbe sincronizzazione aggiuntiva e potrebbe compromettere l'ordine di scrittura dei messaggi. Mantenere un singolo worker garantisce che i messaggi siano scritti nell'ordine esatto di ricezione dalla pipeline, preservando la causalità del flusso dati. Nel caso in cui si voglia scrivere più di un file, è richiesto l'uso di \textit{N} stage di questo tipo, quanti sono i file.

Il messaggio in ingresso allo stage è generico, ma deve implementare l'interfaccia \texttt{message.Serializable}, come molti altri stage della libreria. Per ciascun messaggio ricevuto, viene estratto il payload del messaggio, che poi è scritto nel \texttt{bufio.Writer}~\cite{golang:bufio:writer}. Questa operazione non scrive immediatamente su disco, ma accumula i byte nel buffer in memoria. Il numero di byte scritti è registrato per tracciamento. Successivamente, viene valutata la soglia di flush: se il numero di byte accumulati supera la soglia configurata, il metodo di flush viene invocato per trasmettere immediatamente i dati dal buffer al kernel. Parallelamente al meccanismo di flush basato su soglia, una goroutine ausiliaria rimane in ascolto su un ticker, e ogni volta che l'intervallo di deadline configurata scade, invoca il flush.

Lo stage \textit{File Egress} espone tre metriche per il monitoraggio: la prima conta il numero dei byte scritti, la seconda il numero di errori durante l'operazione di scrittura nel buffer, mentre l'ultima conta gli errori di flushing.

Il \textit{File Egress stage} è ideale per scenari in cui la persistenza locale è sufficiente e la semplicità è prioritaria rispetto alla distribuzione. Un esempio pratico è il logging.

In sintesi, il \textit{File Egress stage} incarna il paradigma di persistenza locale e sequenziale: prende un flusso di messaggi elaborati dalla pipeline e li scrive ordinatamente in un file su disco, offrendo controllo granulare sul buffering tramite soglie dinamiche e flushing periodico, preservazione rigorosa dell'ordine causale, e sincronizzazione robusta verso il \textit{filesystem}. È il componente ideale per conclusioni di pipeline che richiedono archiviazione durabile, facilità di analisi offline, e semplicità operativa.
