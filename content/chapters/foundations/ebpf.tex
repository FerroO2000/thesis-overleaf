\section{eBPF}

L'eBPF (extended Berkeley Packet Filter) è una tecnologia che permette l'esecuzione di programmi in un contesto privilegiato all'interno del kernel Linux, in modo sicuro e controllato, senza dover modificare il sorgente del kernel o caricare moduli kernel tradizionali~\cite{ebpf:what}. Originariamente derivato dal Berkeley Packet Filter, pensato per il filtraggio efficiente dei pacchetti di rete, l'eBPF si è evoluto in una piattaforma generica per estendere dinamicamente le funzionalità del kernel mediante bytecode verificato e, successivamente, compilato JIT in codice nativo.

Dal punto di vista architetturale, l'eBPF introduce una pipeline che coinvolge un compilatore (tipicamente LLVM o GCC) capace di generare bytecode eBPF, un loader in user space (come libbpf o librerie di più alto livello) e un runtime in kernel space che include un interprete, un JIT compiler e un verifier. Il verifier svolge un ruolo cruciale in termini di sicurezza: analizza staticamente il bytecode per garantire l'assenza di loop non terminanti, accessi a memoria fuori limite o altre operazioni potenzialmente pericolose, rifiutando i programmi che non soddisfano i vincoli di sicurezza. Solo i programmi che superano la verifica vengono caricati ed eventualmente compilati JIT per ottenere prestazioni comparabili al codice nativo.

I programmi eBPF possono essere ``agganciati'' (hooked) a numerosi punti di attacco nel kernel: interfacce di rete (XDP, TC), system call, kprobe e uprobe, tracepoint e altri. Ogni programma viene eseguito in risposta a un evento (ad esempio la ricezione di un pacchetto, l'invocazione di una syscall, o un evento di performance), e può aggiornare strutture dati persistenti chiamate map (array, hash map, ring buffer, ecc.) utilizzate per comunicare con lo spazio utente. In ambito osservabilità, questo consente di implementare strumenti avanzati di tracing, profiling e monitoraggio senza richiedere riavvii del sistema o modifiche intrusive alla configurazione del kernel.

La libreria Goccia sfrutta eBPF tramite la libreria Go cilium/ebpf, che fornisce un wrapper Go-nativo per il caricamento e la gestione di programmi eBPF compilati. Lo eBPF Ingress stage si collega a una map di tipo ring buffer nel kernel, attraverso la quale i programmi eBPF inviano eventi verso lo spazio utente. Grazie all'uso dei generics in Go, lo stage eBPF di Goccia può deserializzare i record del ring buffer direttamente in struct tipizzate, permettendo all'utente di definire liberamente il layout dei dati prodotti dal programma eBPF. Questo modello abilita scenari in cui dati di basso livello (syscall, pacchetti di rete, eventi di performance) vengono campionati nel kernel e trasferiti in modo efficiente a una pipeline di elaborazione ad alte prestazioni.