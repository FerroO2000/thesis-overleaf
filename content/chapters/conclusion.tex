\chapter{Conclusioni}
\label{chap:conclusion}

Il presente lavoro di tesi ha affrontato la progettazione e l'implementazione di \textbf{Goccia} (\url{https://github.com/FerroO2000/goccia}), una libreria software \textit{open-source} scritta in Go finalizzata alla costruzione di \textit{data pipeline} concorrenti ad alte prestazioni. L'obiettivo primario era superare i limiti prestazionali intrinseci delle primitive di sincronizzazione standard del linguaggio (i \textit{channel}) in scenari ad alto carico e con elevato grado di parallelismo multicore, fornendo al contempo un'API espressiva e modulare per lo sviluppo di architetture \textit{data-driven}.

Attraverso un'attenta analisi architetturale, è stato definito un modello a stadi disaccoppiato e flessibile (Ingress, Processor, Egress), collegato internamente da Connector implementati tramite \textit{ring buffer lock-free}. L'impiego di operazioni atomiche (Compare-And-Swap) e l'ottimizzazione dell'occupazione in memoria, in particolare attraverso il \textit{padding} delle \textit{cache-line} per mitigare il fenomeno del \textit{false sharing}, hanno permesso di eliminare i lock espliciti e minimizzare l'\textit{overhead} di sincronizzazione. Inoltre, l'adozione di un Worker Pool integrato ha garantito la scalabilità dinamica dell'elaborazione tramite meccanismi di \textit{autoscaling} adattivo.

I risultati ottenuti nella fase di \textit{micro-benchmarking} confermano pienamente la validità delle scelte progettuali. Il confronto diretto in regime stazionario tra i \textit{ring buffer} di Goccia e i \textit{channel} nativi di Go ha evidenziato incrementi prestazionali sostanziali, con uno \textit{speedup} netto compreso tra 1.4x (su architetture ARM64 come Apple M1) e 4.75x (su macchine server x86\_64 basate su AMD EPYC). L'architettura si è dimostrata estremamente resiliente in condizioni di elevata contesa, gestendo in modo efficiente i pattern di \textit{fan-in} (MPSC) e \textit{fan-out} (SPMC) e mitigando il degrado prestazionale causato da risvegli simultanei di molteplici \textit{goroutine}. Tali evidenze dimostrano che il \textit{layer} di trasporto specializzato non costituisce un collo di bottiglia, liberando cicli CPU essenziali per la logica di \textit{business}.

Oltre alla validazione quantitativa, l'efficacia pratica e la robustezza della libreria sono state verificate sul campo attraverso l'integrazione nel sistema di telemetria automobilistica in tempo reale per il prototipo di Formula SAE di SquadraCorse Polito. In questo contesto operativo, Goccia ha gestito con successo l'ingestione continua di datagrammi UDP, la decodifica del protocollo Cannelloni, il \textit{parsing} dei \textit{frame} del CAN bus e il riordino dei messaggi affetti da variabilità di rete, impiegando algoritmi statistici avanzati come il \textit{Double Exponential Smoothing} di Holt per la correzione del \textit{jitter} temporale. La persistenza strutturata verso il database \textit{time-series} QuestDB e l'inclusione nativa del tracciamento distribuito e delle metriche tramite OpenTelemetry hanno infine garantito un'osservabilità completa dell'intero \textit{layer} di elaborazione.

Guardando agli sviluppi futuri, Goccia pone solide fondamenta per evoluzioni ancor più avanzate. Come descritto, il \textit{framework} risulta intrinsecamente predisposto per l'integrazione di protocolli di trasporto a bassa latenza (QUIC) o orientati all'Internet of Things (MQTT), nonché per l'estensione verso logiche di \textit{routing} dinamico (\textit{Content-Based Routing}) e pattern asincroni \textit{Request-Reply} per servizi REST.

In conclusione, questo lavoro dimostra che coniugando l'espressività e la sicurezza del modello di concorrenza di Go con l'efficienza estrema delle strutture dati \textit{hardware-aware}, è possibile realizzare uno strumento infrastrutturale altamente scalabile. Il progetto si consolida così come una libreria di riferimento completa e affidabile, pienamente in grado di soddisfare i requisiti più stringenti dei moderni sistemi di elaborazione dati.
