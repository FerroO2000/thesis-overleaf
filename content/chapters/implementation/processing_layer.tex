\section{Processing Layer}
\label{sec:processing-layer}

Il \textit{Livello di elaborazione} è implementato dal servizio denominato \texttt{sc-telemetry}~\cite{sc-telemetry:github}, eseguito in due istanze distinte per i due bus CAN. Ciascuna istanza realizza, tramite la libreria \textbf{Goccia}, una pipeline di elaborazione a sei stadi che parte dai datagrammi UDP incapsulati in Cannelloni e termina con la persistenza dei segnali CAN in QuestDB.

L’immagine \texttt{scomarferro/sc-telemetry}~\cite{sc-telemetry:dockerhub} incapsula in un unico binario Go l’implementazione necessaria per gestire il flusso di dati proveniente dal veicolo. In fase di avvio, il servizio carica la configurazione leggendo un file YAML (di default \texttt{/app/config/config.yaml}) e applica eventuali override tramite variabili d’ambiente. Il percorso del file di configurazione può essere modificato impostando la variabile \texttt{CONFIG\_PATH}, mentre ogni campo del file YAML può essere sovrascritto da un corrispondente \textit{environment variable}. Questa strategia consente di mantenere una configurazione di base versionata nel repository e, al contempo, di adattare rapidamente i parametri di runtime al contesto specifico senza ricompilare il binario.

La pipeline implementata da \texttt{sc-telemetry} è composta da sei stadi principali:
\begin{itemize}
  \item \textbf{UDP Ingress}: riceve i datagrammi UDP provenienti dalla scheda SCanner tramite il proxy UDP e li inserisce nella pipeline.
  \item \textbf{Cannelloni Decoder Processor}: prende in ingresso i payload dei pacchetti UDP e decodifica il payload secondo la specifica del protocollo Cannelloni.
  \item \textbf{ROB Processor (Re-Order Buffer)}: ordina i messaggi dello stage precedente in base al numero di sequenza, compensando il fatto che i datagrammi UDP possono arrivare fuori ordine o con \textit{jitter} significativo. Oltre al riordino, lo stadio corregge i timestamp associati ai messaggi applicando tecniche di smoothing temporale descritte nei capitoli precedenti, in modo da stimare con maggiore precisione l’istante effettivo di generazione del messaggio a bordo vettura.
  \item \textbf{CAN Processor}: prende in ingresso i messaggi Cannelloni riordinati, estrae i frame CAN grezzi e li decodifica secondo le specifiche contenute nel file DBC~\cite{dbc:format}. Questo tipo di file rappresenta lo standard del settore automobilistico per definire la struttura dei messaggi trasmessi nelle linee CAN. Il file DBC viene letto, in fase di inizializzazione, dalla libreria \texttt{acmelib}~\cite{acmelib:github}.
  \item \textbf{CAN Message Handler (Custom Processor)}: è l’unico stadio della pipeline implementato specificamente per questa applicazione, e ha il compito di trasformare i messaggi CAN decodificati in messaggi pronti per essere inseriti in QuestDB.
  \item \textbf{QuestDB Egress}: si occupa di inserire i messaggi nel database time-series.
\end{itemize}

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{images/implementation/pipeline.png}
  \caption{Stage di Goccia usati in sc-telemetry}
  \label{fig:sc-telemetry-pipeline}
\end{figure}